#!/bin/bash
set -e

REPOS=()
REPO_LIST="REPO_LIST.txt"
PKG_DIR="./sources/"        # Install Directory
TIME_OUT="10"               # Connection timeout
MAX_TIMEOUT="300"           # Full curl timeout
SUCCESS_URLS=()             # Array of program urls
SUCCESS_PATCH=()            # Array of patch urls
MD5SUMS="$PKG_DIR/md5sums"  # Checksum list for LFS Packages
USER_AGENT="Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0"

load_repos() {
    while IFS= read -r line; do
        if [[ "$line" == \#* ]] || [[ -z "$line" ]]; then
            :
        else
            REPOS+=("$line")
        fi
    done < "$REPO_LIST"

    local repo_num=${#REPOS[@]}
    local repo_prompt="repo"

    if [ "$repo_num" -gt 1 ]; then
        repo_prompt="${repo_prompt}s"
    fi

    echo -e "Loaded repository list [$repo_num $repo_prompt] to memory..."
}

pkg_search() {
    # Search for a single package
    local pkg="$1"

    echo "Searching for $pkg..."

    for repo in "${REPOS[@]}"; do
        path=$(curl -fsSL "$repo" --connect-timeout "$TIME_OUT" \
            -A "$USER_AGENT" \
            | grep -oE "$pkg[^\"]*\.tar\.[^\" ]+" \
            | head -n 1)

        if [ -n "$path" ]; then
            SUCCESS_URLS+=("$repo$path")
            echo -e "$repo$path ... [FOUND]"
        else
            echo -e "$repo ... [NOT FOUND]"
        fi
    done

    # Ask download to do it's job
    if ! file_exists "$path"; then
        download_pkg "$path" "pkg"
        success "$path" "pkg"
    fi
}

patch_search() {
    # Search for a single patch
    local name="$1"

    echo "Searching for $name Patch..."

    for repo in "${REPOS[@]}"; do
        path=$(curl -fsSL "$repo" --connect-timeout "$TIME_OUT" \
            -A "$USER_AGENT" \
            | grep -oE "$name[^\"]*\.patch" \
            | head -n 1)

        if [ -n "$path" ]; then
            SUCCESS_PATCH+=("$repo$path")
            echo -e "  $SUCCESS_PATCH ... [FOUND]"
        else
            echo -e "  $repo ... [NOT FOUND]"
        fi
    done

    # Ask download to do it's job
    if ! file_exists "$path"; then
        download_pkg "$path" "patch"
        success "$path" "patch"
    fi
}

file_exists() {
    # Check if a package has already been downloaded
    local name="$1"
    full_file=$(realpath "$PKG_DIR/$name")

    if [[ ! -f "$full_file" ]]; then
        echo -e "  Package [$name] does not exist in: $PKG_DIR"
        return 1
    else
        file_size_bytes=$(wc -c < "$full_file")
        if [[ "$name" == *".patch" ]]; then
            file_size=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / 1024}")
            local measurement="KB"
        else
            file_size=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / 1048576}")
            local measurement="MB"
        fi
        echo -e "Package [$name] already exists in: $PKG_DIR\n  Size: $file_size $measurement\n  Location: $full_file"
        return 0
    fi
}

download_pkg() {
    # Download a single package
    # Note: If the download passes the timeout it tries the next successful link
    local name="$1"
    local filetype="$2"
    local idx=0

    if [[ "$filetype" == "pkg" ]]; then
        local -a url_list=("${SUCCESS_URLS[@]}")
    elif [[ "$filetype" == "patch" ]]; then
        local -a url_list=("${SUCCESS_PATCH[@]}")
    fi

    for pkg_url in "${url_list[@]}"; do
        echo -e "Downloading: $name\n  From: $pkg_url"

        if curl -fsSL "$pkg_url" \
            -A "$USER_AGENT" \
            -o "$PKG_DIR/$name" \
            --max-time "$MAX_TIMEOUT"; then

            check_sums "$name"
            return 0
        else
            local exit_code="$?"
            echo -e "Download failed with exit code $exit_code"

            # Clean up failed downloads
            clean_up "$name"
            ((idx++))

            if [ "$idx" -eq "${#SUCCESS_URLS[@]}" ]; then
                failure "$name"
            fi
        fi
    done
}

verify_checksum() {
    local filename="$1"
    local expected_hash="$2"

    if [[ ! -f "$PKG_DIR/$filename" ]]; then
        echo -e "File Not Found: $filename"
        return 1
    fi

    local actual_hash=$(md5sum "$PKG_DIR/$filename" | awk '{print $1}')

    if [[ "$expected_hash" == "$actual_hash" ]]; then
        echo -e "  Checksum verified: $filename"
        return 0
    else
        local prompt="  Checksum failed to verify: $filename\n"
        prompt+="  - Expected: $expected_hash\n"
        prompt+="  - Recieved: $actual_hash"
        echo -e "$prompt"
        return 1
    fi
}

check_sums() {
    # Verify the package matches the checksum
    local name="$1"
    local lfs_checksum="https://www.linuxfromscratch.org/lfs/view/stable/md5sums"

    if [ -z "$MD5SUMS" ] || [ ! -f "$MD5SUMS" ]; then
        curl "$lfs_checksum" -o "$PKG_DIR/md5sums"
    fi

    while IFS= read -r line; do
        [[ -z "$line" ]] || [[ "$line" == \#* ]] && continue

        if [[ "$line" =~ "$name" ]]; then
            local expected_hash=$(echo "$line" | awk '{print $1}')
            local filename=$(echo "$line" | awk '{$1=""; print $0}' | xargs)

            if [[ "$filename" == *".patch" ]]; then
                echo "Verifying patch: $filename"
                verify_checksum "$filename" "$expected_hash"
            else
                echo "Verifying program: $filename"
                verify_checksum "$filename" "$expected_hash"
            fi
        fi
    done < "$MD5SUMS"
}

clean_up() {
    # Clean up any files made from failed download attempts
    local name="$1"
    rm -rfv "$PKG_DIR/$name"
}

failure() {
    # Tell the user a file couldn't be downloaded!
    local name="$1"
    tries=$((${#SUCCESS_URLS} - 1)) # Number of URLS attempted
    echo -e "Unable to download $name (after $tries tries)"
    exit 1
}

success() {
    local path="$1"
    local filetype="$2"
    local full_file=$(realpath "$PKG_DIR/$path")
    local file_size_bytes=$(wc -c < "$full_file")
    local prompt="Successfully downloaded $path!\n"

    if [[ "$filetype" == "patch" ]]; then
        local file_size=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / 1024}")
        prompt+="  Size: $file_size KB\n"
    elif [[ "$filetype" == "pkg" ]]; then
        local file_size=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / 1048576}")
        prompt+="  Size: $file_size MB\n"
    fi

    prompt+="  Location: $full_file"
    echo -e "$prompt"
}

main() {
    local name="$1"     # Name of the package

    [[ ! -d "$PKG_DIR" ]] && { mkdir -pv "$PKG_DIR"; }
    [[ -z "$name" ]] && { echo "Usage: spkg <package>"; return 1; }

    if [ ! -f "$REPO_LIST" ]; then
        local prompt="# Use # to comment out repos\n# Add repo urls below"
        echo -e "$prompt" > "$REPO_LIST"
        echo -e "$REPO_LIST created in $(realpath $REPO_LIST)"
        exit 1
    fi

    load_repos
    pkg_search "$name"
    patch_search "$name"
}

main "$@"
