#!/bin/bash
set -e -u

# Prog specific
VERSION="1.0.0"

# CLI Arg Variables
FORCE_SORT=0                # Force sorting the repositories
FORCE_PATCH=0               # Force searching for patches
QUIET=0                     # Suppress the majority of print statements
FORCE_IGNORE=0              # Ignore the checksum file and force a download
VERBOSE=0                   # Print additional debugging information

# Global Variables
REPOS=()                    # Array of repositories (Auto-filled)
REPO_LEN=0                  # Length of repository array (Auto-calculated)
REPO_LIST="REPO_LIST.txt"   # List to fill repository array
PKG_DIR="./sources/"        # Install Directory
TIME_OUT="10"               # Connection timeout
MAX_TIMEOUT="300"           # Full curl timeout
SUCCESS_URLS=()             # Array of program urls
SUCCESS_PATCH=()            # Array of patch urls
MD5SUMS="$PKG_DIR/md5sums"  # Checksum list for LFS Packages
SORTING_IN_PROGRESS=0       # Boolean for cleanup
ACTIVE_DOWNLOAD=0           # Boolean for cleanup
ACTIVE_PACKAGE=""           # Full package name of the download in progress

LFS_CHECKSUM="https://www.linuxfromscratch.org/lfs/view/stable/md5sums"
USER_AGENT="Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0"

# Colors and shit
TXT_END='\033[0m'
TXT_BOLD='\033[1m'
TXT_RED='\033[0;31m'
TXT_GREEN='\033[0;32m'
TXT_YELLOW='\033[0;33m'
TXT_CYAN='\033[0;36m'
TXT_BOLD_RED='\033[1;31m'
TXT_BOLD_GREEN='\033[1;32m'
TXT_BOLD_YELLOW='\033[1;33m'
TXT_BOLD_CYAN='\033[1;36m'

trap interrupt_cleanup SIGINT

test_repo_speed() {
    # Test actual download speed by downloading first 1MB of a file
    local repo="$1"

    # Find a test file
    local test_file=$(curl -fsSL "$repo" \
        -A "$USER_AGENT" \
        --connect-timeout "$TIME_OUT" \
        --max-time 5 \
        | grep -oE "[^\"]*\.tar\.[^\" ]+" \
        | head -n 1)

    [ "$VERBOSE" -eq 1 ] && { echo -e "$test_file"; }

    if [ -z "$test_file" ]; then
        echo "999"
        return
    fi

    local test_url="$repo$test_file"
    local start_time=$(date +%s.%N)

    # Download first 1MB
    if curl -fsSL "$test_url" \
        -A "$USER_AGENT" \
        --connect-timeout "$TIME_OUT" \
        --max-time 10 \
        -r 0-10485755 \
        -o /dev/null 2>/dev/null; then

        local end_time=$(date +%s.%N)
        awk "BEGIN {printf \"%.3f\", $end_time - $start_time}"
    else
        echo "999"
    fi
}

create_repolist() {
    # Create a generic repository list
    local content="# This is a generic repo list created by spkg\n"
    content+="https://lfs.gnlug.org/pub/lfs/lfs-packages/12.4/\n"
    content+="https://ftp.lfs-matrix.net/pub/lfs/lfs-packages/12.4/\n"
    content+="https://ftp.osuosl.org/pub/lfs/lfs-packages/12.4/\n"
    content+="https://mirror.download.it/lfs/pub/lfs/lfs-packages/12.4/\n"
    content+="https://mirror.koddos.net/lfs/lfs-packages/12.4/\n"
    content+="https://mirror.proximity-bg.com/LFS/lfs-packages/12.4/\n"
    content+="https://mirror.dogado.de/LFS/lfs-packages/12.4/\n"
    content+="https://ftp.ludd.ltu.se/pub/lfs/lfs-packages/12.4/\n"
    content+="https://mirror.metanet.ch/LFS/lfs-packages/12.4/\n"
    content+="https://lfs.it-privat.dk/pub/lfs/lfs-packages/12.4/\n"
    content+="https://mirror-hk.koddos.net/lfs/lfs-packages/12.4/\n"
    content+="https://mirrors.ustc.edu.cn/lfs/lfs-packages/12.4/\n"
    content+="https://mirror.freedif.org/pub/lfs/lfs-packages/12.4/\n"

    if [ "$VERBOSE" -eq 1 ]; then
        echo -e "Creating generic $REPO_LIST"
    fi
    echo -e "$content" > "$REPO_LIST"
}

load_repos() {
    local skip_sort=0
    REPO_LEN=0

    while IFS= read -r line; do
        # if any comment in the REPO_LIST contains '# --lock' it will not sort.
        if [[ "$line" == *"# --lock"* ]] || [[ "$line" == *"#--lock"* ]]; then
            skip_sort=1
            continue
        fi

        if [[ "$line" == \#* ]] || [[ -z "$line" ]]; then
            :
        else
            REPOS+=("$line")
        fi
    done < "$REPO_LIST"

    REPO_LEN=${#REPOS[@]}

    if [ "$QUIET" -eq 0 ]; then
        local prompt="${TXT_BOLD}Loaded repository list to memory ...${TXT_END}"
        local repo_prompt="repo"

        if [ "$REPO_LEN" -gt 1 ]; then
            repo_prompt="${repo_prompt}s"
            prompt+=" ${TXT_BOLD}[${TXT_BOLD_GREEN}$REPO_LEN $repo_prompt${TXT_END}${TXT_BOLD}]"
        else
            prompt+=" ${TXT_BOLD}[${TXT_BOLD_RED}$REPO_LEN $repo_prompt${TXT_END}${TXT_BOLD}]"
        fi

        echo -e "$prompt"
    fi

    if [ "$VERBOSE" -eq 1 ]; then
        for repo in ${REPOS[@]}; do
            echo -e "  $repo"
        done
    fi

    # Sort repos by speed
    local counter=1
    if [ "$REPO_LEN" -gt 1 ]; then
        if [ "$skip_sort" -eq 0 ] || [ "$FORCE_SORT" -eq 1 ]; then
            SORTING_IN_PROGRESS=1

            if [ "$QUIET" -eq 0 ]; then
                echo -e "${TXT_BOLD}Testing repository speeds...${TXT_END}"
            fi

            local -a repo_speed_pairs
            for repo in "${REPOS[@]}"; do
                local speed=$(test_repo_speed "$repo")
                if [ "$QUIET" -eq 0 ]; then
                    if (( $(awk "BEGIN {print ($speed < 5)}") )); then
                        local speed_prompt="${TXT_BOLD_GREEN}${speed:0:5}s${TXT_END}"
                    elif (( $(awk "BEGIN {print ($speed < 10)}") )); then
                        local speed_prompt="${TXT_BOLD_YELLOW}${speed:0:5}s${TXT_END}"
                    else
                        local speed_prompt="${TXT_BOLD_RED}${speed:0:5}s${TXT_END}"
                    fi

                    if [ "$VERBOSE" -eq 1 ]; then
                        local prompt="  $repo ... "
                        prompt+="${TXT_BOLD}[${speed_prompt}${TXT_BOLD}]${TXT_END}"
                        echo -e "$prompt"
                    else
                        echo -en "\e[K  $counter/$REPO_LEN: $repo ... ${TXT_BOLD}[$speed_prompt${TXT_BOLD}]\r"
                    fi
                fi

                repo_speed_pairs+=("$repo|$speed")
                ((counter++))
            done

            IFS=$'\n' repo_speed_pairs=($(sort -t'|' -k2 -n <<<"${repo_speed_pairs[*]}"))
            unset IFS

            REPOS=()
            for pair in "${repo_speed_pairs[@]}"; do
                REPOS+=("${pair%|*}")
            done

            if [ "$QUIET" -eq 0 ]; then
                local prompt="${TXT_BOLD}Repositories sorted by speed${TXT_END}"
                prompt+=" - fastest first"
                echo -e "$prompt"
            fi

            write_sorted_repos
            SORTING_IN_PROGRESS=0

        elif [ "$skip_sort" -eq 1 ]; then
            if [ "$QUIET" -eq 0 ]; then
                local prompt="${TXT_BOLD}Repository sorting locked${TXT_END}"
                prompt+=" - using list as-is"
                echo -e "$prompt"
            fi
        fi
    elif [ "$REPO_LEN" -eq 0 ]; then
        local err_prompt="${TXT_BOLD_RED}[Error]:${TXT_END} "
        err_prompt+="There are no repositories in $REPO_LIST"
        echo -e "$err_prompt" >&2
        exit 1
    fi
}

write_sorted_repos() {
    # Write the sorted repos to the list and lock it
    local temp_file="${REPO_LIST}.tmp"

    local content="# Repositories soirted by fastest download speed\n"
    content+="# This file is locked, remove any line with '# --lock' to to re-test and re-sort\n"
    echo -e "$content" > "$temp_file"

    local limit=3
    for i in "${!REPOS[@]}"; do
        if [ "$i" -lt "$limit" ]; then
            echo "${REPOS[$i]}" >> "$temp_file"
            if [ "$VERBOSE" -eq 1 ]; then
                echo -e "${REPOS[$i]} - added to $temp_file"
            fi
        else
            echo "# ${REPOS[$i]}" >> "$temp_file"
            if [ "$VERBOSE" -eq 1 ]; then
                echo -e "# ${REPOS[$i]} - added to $temp_file"
            fi
        fi
    done

    # Overwrite original
    mv "$temp_file" "$REPO_LIST"
    if [ "$QUIET" -eq 0 ]; then
        if [ "$VERBOSE" -eq 1 ]; then
            echo -e "${TXT_YELLOW}$REPO_LIST overwritten with $temp_file${TXT_END}"
        fi
        echo -e "${TXT_BOLD}Updated $REPO_LIST with sorted repositories...${TXT_END}"
    fi
}

pkg_search() {
    local pkg="$1"
    local path=""
    local prefix=""

    if [ "$QUIET" -eq 0 ]; then
        prefix="\n"
    fi
    echo -e "$prefix${TXT_BOLD}Searching for $pkg...${TXT_END}"

    if [ "$VERBOSE" -eq 1 ]; then
        local args="-fL"
    else
        local args="-fsSL"
    fi

    local count=1
    for repo in "${REPOS[@]}"; do
        path=$(curl $args "$repo" \
            --connect-timeout "$TIME_OUT" \
            -A "$USER_AGENT" --no-progress-bar \
            | grep -oE "$pkg[^\"]*\.tar\.[^\" ]+" \
            | head -n 1)

        if [ -n "$path" ]; then
            SUCCESS_URLS+=("$repo$path")
            if [ "$QUIET" -eq 1 ]; then
                local prompt="\e[K  $path ${TXT_BOLD_GREEN}[FOUND]${TXT_END} in "
                prompt+="${TXT_BOLD}${#SUCCESS_URLS[@]}/${#REPOS[@]}${TXT_END} repositories\r"
                echo -en "$prompt"
            else
                echo -e "  $repo$path ... ${TXT_BOLD_GREEN}[FOUND]${TXT_END}"
            fi
        else
            if [ "$QUIET" -eq 1 ]; then
                local prompt="\e[K  $pkg ${TXT_BOLD_RED}[NOT FOUND]${TXT_END} in "
                prompt+="${TXT_BOLD}$count${TXT_END} repositories\r"
                echo -en "$prompt"
            else
                echo -e "  $repo ... ${TXT_BOLD_RED}[NOT FOUND]${TXT_END}"
            fi
            ((count++))
        fi
    done

    if [ "${#SUCCESS_URLS[@]}" -eq 0 ]; then
        if [ "$REPO_LEN" -gt 1 ]; then
            local repo_prompt="repositories"
        else
            local repo_prompt="repository"
        fi

        local err_prompt="${TXT_BOLD_RED}[Error]:${TXT_END} "
        err_prompt+="\"$pkg\" was not found in $REPO_LEN $repo_prompt..."
        echo -e "\n$err_prompt" >&2
        return 1
    fi

    # Ask download to do it's job
    if [ "$FORCE_IGNORE" -eq 0 ]; then
        if ! file_exists "$path"; then
            if in_sumlist "$path"; then
                if download_pkg "$path" "pkg"; then
                    success "$path" "pkg"
                else
                    local err_prompt="${TXT_BOLD_RED}[Error]:${TXT_END} "
                    err_prompt+="Unable to download $path after trying all available mirrors."
                    echo -e "$err_prompt" >&2
                    exit 1
                fi
            else
                local err_prompt="${TXT_BOLD_RED}[Error]:${TXT_END} "
                err_prompt+="\"$path\" not in official LFS package list - aborting"
                echo -e "$err_prompt" >&2
                exit 1
            fi
        fi
    fi
}

patch_search() {
    local name="$1"
    local path=""

    if [ "$QUIET" -eq 0 ]; then
        echo -e "\n${TXT_BOLD}Searching for $name Patch...${TXT_END}"
    fi

    if [ "$VERBOSE" -eq 1 ]; then
        local args="-fL"
    else
        local args="-fsSL"
    fi

    for repo in "${REPOS[@]}"; do
        path=$(curl $args "$repo" --connect-timeout "$TIME_OUT" \
            -A "$USER_AGENT" --no-progress-meter \
            | grep -oE "$name[^\"]*\.patch" \
            | head -n 1)

        if [ -n "$path" ]; then
            SUCCESS_PATCH+=("$repo$path")
            if [ "$QUIET" -eq 0 ]; then
                echo -e "  $repo$path ... ${TXT_BOLD_GREEN}[FOUND]${TXT_END}"
            fi
        else
            if [ "$QUIET" -eq 0 ]; then
                echo -e "  $repo ... ${TXT_BOLD_YELLOW}[NOT FOUND]${TXT_END}"
            fi
        fi
    done

    if [ "${#SUCCESS_PATCH[@]}" -eq 0 ]; then
        local prompt="${TXT_BOLD_CYAN}[Note]:${TXT_END} "
        prompt+="No patches were found for $name (this may be normal)."
        echo -e "$prompt"
        return 0 # Most packages will not have patches
    fi

    # Ask download to do it's job
    if ! file_exists "$path"; then
        if in_sumlist "$path"; then
            if download_pkg "$path" "patch"; then
                success "$path" "patch"
            fi
        else
            local prompt="${TXT_BOLD_YELLOW}[Warning]:${TXT_END} "
            prompt+="Patch $path not in official LFS list - skipping"
            echo -e "$prompt"
            return 0 # Not Fatal for patches
        fi
    fi

    return 0 # Even a failure is a Success in some ways
}

file_exists() {
    local name="$1"
    full_file=$(realpath "$PKG_DIR/$name")

    if [[ ! -f "$full_file" ]]; then
        if [ "$QUIET" -eq 0 ]; then
            prompt="  ${TXT_BOLD_YELLOW}File [${TXT_END}${TXT_YELLOW}$name${TXT_BOLD_YELLOW}] "
            prompt+="${TXT_BOLD_YELLOW}does not exist in:${TXT_END} $PKG_DIR"
            echo -e "$prompt"
        fi
        return 1
    else
        file_size_bytes=$(wc -c < "$full_file")
        if [[ "$name" == *".patch" ]]; then
            file_size=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / 1024}")
            local measurement="KB"
            local file_type="Patch"
        else
            file_size=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / 1048576}")
            local measurement="MB"
            local file_type="Package"
        fi

        local prompt="\n${TXT_BOLD_YELLOW}$file_type [${TXT_YELLOW}$name${TXT_BOLD_YELLOW}] already exists in:${TXT_END} $PKG_DIR"
        prompt+="\n  ${TXT_BOLD}Size:${TXT_END} $file_size $measurement\n"
        prompt+="  ${TXT_BOLD}Location:${TXT_END} $full_file"
        echo -e "$prompt"
        return 0
    fi
}

download_pkg() {
    local name="$1"
    local filetype="$2"
    local idx=0

    if [[ "$filetype" == "pkg" ]]; then
        local -a url_list=("${SUCCESS_URLS[@]}")
    elif [[ "$filetype" == "patch" ]]; then
        local -a url_list=("${SUCCESS_PATCH[@]}")
    fi

    ACTIVE_DOWNLOAD=1
    ACTIVE_PACKAGE="$name"

    for pkg_url in "${url_list[@]}"; do
        echo -e "\n${TXT_BOLD}Downloading:${TXT_END} $name\n  From: $pkg_url"

        if [ "$VERBOSE" -eq 1 ]; then
            local command_args="-fL"
        else
            if [ "$QUIET" -eq 0 ]; then
                local command_args="-fSL"
            else
                local command_args="-fsSL"
            fi
        fi

        if curl $command_args "$pkg_url" \
            -A "$USER_AGENT" \
            -o "$PKG_DIR/$name" \
            --max-time "$MAX_TIMEOUT"; then

            if [ "$FORCE_IGNORE" -eq 0 ]; then
                if check_sums "$name"; then
                    ACTIVE_DOWNLOAD=0
                    return 0 # Success
                else
                    echo -e "${TXT_BOLD_RED}Checksum verification failed${TXT_END}, trying next mirror..."
                    ((idx++))

                    if [ "$idx" -eq "${#url_list[@]}" ]; then
                        return 1 # All mirrors (and checksums) failed
                    fi
                    continue
                fi
            fi
        else
            local exit_code="$?"
            echo -e "  ${TXT_RED}Download failed with exit code $exit_code${TXT_END}" >&2

            # Clean up failed downloads
            clean_up "$name"
            ((idx++))

            if [ "$idx" -eq "${#url_list[@]}" ]; then
                return 1 # All mirrors failed
            fi
        fi
    done

    return 1 # Fallback
}

verify_checksum() {
    local filename="$1"
    local expected_hash="$2"

    if [[ ! -f "$PKG_DIR/$filename" ]]; then
        echo -e "File Not Found: $filename" >&2
        return 1
    fi

    local actual_hash=$(md5sum "$PKG_DIR/$filename" | awk '{print $1}')

    if [[ "$expected_hash" == "$actual_hash" ]]; then
        local prompt="  ${TXT_CYAN}Checksum verified!${TXT_END}"
        if [ "$VERBOSE" -eq 1 ]; then
                    prompt+="  - Expected: $expected_hash\n"
                    prompt+="  - Received: $actual_hash"
        fi
        echo -e "$prompt"
        return 0
    else
        local prompt="  ${TXT_RED}Checksum failed to verify: $filename${TXT_END}\n"
        prompt+="  - Expected: $expected_hash\n"
        prompt+="  - Received: $actual_hash"
        echo -e "$prompt" >&2
        return 1
    fi
}

download_sumlist() {
    if [ "$QUIET" -eq 0 ]; then
        echo -e "${TXT_BOLD}Download LFS checksum file...${TXT_END}"
    fi

    if [ "$VERBOSE" -eq 1 ]; then
        local args="-fL"
    else
        local args="-fsSL"
    fi

    curl $args "$LFS_CHECKSUM" \
        -A "$USER_AGENT" \
        --connect-timeout "$TIME_OUT" \
        --max-time 10 \
        -o "$MD5SUMS"
}

in_sumlist() {
    # Check if a file pulled from repository is in checksum list
    local name="$1"

    if [ -s "$MD5SUMS" ]; then
        download_sumlist
    fi

    while IFS= read -r line; do
        [ -z "$line" ] || [[ "$line" == \#* ]] && continue

        local filename=$(echo "$line" | awk '{$1=""; print $0}' | xargs)
        if [[ "$filename" == "$name" ]]; then
            if [ "$QUIET" -eq 0 ]; then
                echo -e "  ${TXT_BOLD_GREEN}$name found in md5sums list${TXT_END}"
            fi
            return 0 # Found in list
        fi
    done < "$MD5SUMS"

    local err_prompt="  ${TXT_BOLD_RED}$name not found in md5sums list${TXT_END}"
    err_prompt+=" - skipping download"
    echo -e "$err_prompt" >&2
    return 1 # Not Found
}

check_sums() {
    # Verify the package matches the checksum
    local name="$1"
    local found=0 # boolean

    if [ -z "$MD5SUMS" ] || [ ! -f "$MD5SUMS" ]; then
        download_sumlist
    fi

    while IFS= read -r line; do
        [[ -z "$line" ]] || [[ "$line" == \#* ]] && continue

        if [[ "$line" =~ "$name" ]]; then
            found=1
            local expected_hash=$(echo -e "$line" | awk '{print $1}')
            local filename=$(echo -e "$line" | awk '{$1=""; print $0}' | xargs)

            if [[ "$filename" == *".patch" ]]; then
                if [ "$QUIET" -eq 0 ]; then
                    echo -e "\n${TXT_BOLD}Verifying patch:${TXT_END} $filename"
                fi
                if ! verify_checksum "$filename" "$expected_hash"; then
                    clean_up "$filename"
                    return 1 # Checksum failed
                fi
            else
                if [ "$QUIET" -eq 0 ]; then
                    echo -e "\n${TXT_BOLD}Verifying program:${TXT_END} $filename"
                fi
                if ! verify_checksum "$filename" "$expected_hash"; then
                    clean_up "$filename"
                    return 1 # Checksum failed
                fi
            fi
        fi
    done < "$MD5SUMS"

    # Make sure file is found in MD5 before saving to the disk.
    if [ "$found" -eq 0 ]; then
        local err_prompt="${TXT_BOLD_RED}[Error]:${TXT_END} "
        err_prompt+="\"$name\" not found in md5sum list - cannot verify integrity"
        echo -e "$err_prompt" >&2
        clean_up "$name"
        return 1
    fi

    return 0 # All checksums passed
}

clean_up() {
    local name="$1"
    rm -rfv "$PKG_DIR/$name"
}

failure() {
    local name="$1"
    tries=$((${#SUCCESS_URLS} - 1)) # Number of URLS attempted
    echo -e "${TXT_BOLD_RED}Unable to download $name (after $tries tries)${TXT_END}" >&2
}

success() {
    # numfmt will thrown an error if the file doesn't exist
    local path="$1"
    local full_file=$(realpath "$PKG_DIR/$path")
    local size=$(numfmt --to=iec --suffix=B --format="%.2f" "$(wc -c < "$full_file")")

    local prompt="${TXT_BOLD_GREEN}Successfully downloaded:${TXT_END} $path"
    prompt+="\n  ${TXT_BOLD}Size:${TXT_END} $size"
    prompt+="\n  ${TXT_BOLD}Location:${TXT_END} $full_file"
    echo -e "$prompt"
}

interrupt_cleanup() {
    echo -e "\nCTRL+C pressed. Performing cleanup..." >&2

    if [ "$SORTING_IN_PROGRESS" -eq 1 ]; then
        echo -e "${TXT_BOLD_RED}$(rm -rvf "$REPO_LIST") ${TXT_RED}(incomplete)${TXT_END}" >&2
    fi

    if [ "$ACTIVE_DOWNLOAD" -eq 1 ]; then
        echo -e "${TXT_BOLD_RED}$(rm -rfv "$PKG_DIR$ACTIVE_PACKAGE") ${TXT_RED}(incomplete)${TXT_END}" >&2
    fi

    exit 130
}

help_info() {
    prog_usage

    local prompt="Easily download a specific package from a repository.\n"
    prompt+="\n  -f, --force-sort\tforce the downloader to re-sort the repositories"
    prompt+="\n  -p, --patch\t\tforce the downloader to check for patches"
    prompt+="\n  -q, --quiet\t\tsuppress the majority of the output"
    prompt+="\n  -I, --ignore\t\t[!] Ignore the checksum file (Not Recommended)"
    prompt+="\n\n  -h, --help\t\tdisplay this help and exit"
    prompt+="\n  -v, --version\t\toutput version information and exit"
    prompt+="\n\nReport bugs to: https://github.com/RileyMeta/spkgs-lfs/pulls"

    echo -e "$prompt"
}

version_info() {
    local prompt="spkg (Simple Package) $VERSION"
    prompt+="\nCopyright (C) 2025 Riley Ava."
    prompt+="\nLicense MPL-2: Mozilla Public License 2.0 <https://www.mozilla.org/en-US/MPL/2.0/>."
    prompt+="\nThis is free software: you are free to change and redistribute it."
    prompt+="\nThere is NO WARRANTY, to the extent permitted by law."
    prompt+="\n\nWritten by Riley Ava."
    echo -e "$prompt"
}

prog_usage() {
    echo -e "Usage: spkg [options] <package>" >&2
}

main() {
    [[ ! -d "$PKG_DIR" ]] && { mkdir -pv "$PKG_DIR"; }

    if [ "$#" -eq 0 ] || [ ! -s "$REPO_LIST" ]; then
        if [ "$#" -eq 0 ] && [ -s "$REPO_LIST" ]; then
            prog_usage
            exit 1
        else
            if [ ! -s "$MD5SUMS" ]; then
                download_sumlist
            fi

            create_repolist
            load_repos
            echo -e "${TXT_BOLD_GREEN}$REPO_LIST created in:${TXT_END} $(realpath $REPO_LIST)" >&2
        fi
    fi

    while getopts ":hVvfpqI-:" opt; do
        case "$opt" in
            h)
                help_info
                exit 0
                ;;
            V)
                version_info
                exit 0
                ;;
            v)  VERBOSE=1
                ;;
            f)
                FORCE_SORT=1
                ;;
            p)
                FORCE_PATCH=1
                ;;
            q)
                QUIET=1
                ;;
            I)
                FORCE_IGNORE=1
                ;;
            -)
                # Handle long options
                case "$OPTARG" in
                    help)
                        help_info
                        exit 0
                        ;;
                    version)
                        version_info
                        exit 0
                        ;;
                    verbose)
                        VERBOSE=1
                        ;;
                    force-sort)
                        FORCE_SORT=1
                        ;;
                    patch)
                        FORCE_PATCH=1
                        ;;
                    quiet)
                        QUIET=1
                        ;;
                    ignore)
                        FORCE_IGNORE=1
                        ;;
                    *)
                        echo -e "--$OPTARG is not recognized." >&2
                        echo -e "Use '--help' to see all available options." >&2
                        exit 1
                        ;;
                esac
                ;;
            \?)
                echo -e "-$OPTARG is not recognized." >&2
                echo -e "Use '--help' to see all available options." >&2
                exit 1
                ;;
            :)
                echo -e "Option -$OPTARG requires an argument." >&2
                exit 1
                ;;
        esac
    done

    shift $((OPTIND - 1))
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        prog_usage
        exit 1
    fi

    if [ ! -s "$MD5SUMS" ]; then
        download_sumlist
    fi

    load_repos
    pkg_search "$name"

    if [ "$FORCE_PATCH" -eq 1 ]; then
        patch_search "$name"
    fi
}

main "$@"
